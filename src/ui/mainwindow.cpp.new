#include "ui/mainwindow.h"
#include "ui_mainwindow.h"
#include "ui/filesystem_mount_dialog.h"
#include "ui/mainwindow_file_ops.h"
#include "ui/mainwindow_dialogs.h"
#include <QMessageBox>
#include <QInputDialog>
#include <QListWidgetItem>
#include <QDir>
#include <QHeaderView>
#include <QDateTime>
#include <QFileDialog>
#include <QDragEnterEvent>
#include <QDropEvent>
#include <QMimeData>
#include <QCalendarWidget>
#include <QDialogButtonBox>
#include <QVBoxLayout>
#include <QLabel>
#include <QSpinBox>
#include <QComboBox>
#include <QTableWidget>
#include <QFileInfo>
#include <QFormLayout>
#include <QDebug>

// Forward declarations for the file operations and dialogs handlers
static std::unique_ptr<MainWindowFileOps> fileOps;
static std::unique_ptr<MainWindowDialogs> dialogHandler;

MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent),
                                          ui(new Ui::MainWindow)
{
    ui->setupUi(this);
    
    // Create filesystem in the current directory
    fs = std::make_unique<FileSystem>("my_virtual_disk.fs");
    
    // Force format the filesystem initially to ensure it exists
    fs->format();

    // Initialize UI components
    ui->fileListWidget->setEnabled(false);
    ui->fileContentTextEdit->setEnabled(false);
    ui->saveButton->setEnabled(false);
    ui->mkdirButton->setEnabled(false);
    ui->createFileButton->setEnabled(false);
    ui->searchLineEdit->setEnabled(false);
    ui->searchButton->setEnabled(false);
    ui->fsDetectButton->setEnabled(true);

    // Set up file list drag and drop
    ui->fileListWidget->setContextMenuPolicy(Qt::CustomContextMenu);
    ui->fileListWidget->setDragEnabled(true);
    ui->fileListWidget->setAcceptDrops(true);
    ui->fileListWidget->setDropIndicatorShown(true);
    ui->fileListWidget->setDefaultDropAction(Qt::MoveAction);
    setAcceptDrops(true);

    // Connect signals and slots
    connect(ui->fileListWidget, &QListWidget::customContextMenuRequested, this, &MainWindow::on_fileListWidget_customContextMenuRequested);
    connect(ui->searchButton, &QPushButton::clicked, this, &MainWindow::on_searchButton_clicked);
    connect(ui->fsDetectButton, &QPushButton::clicked, this, &MainWindow::on_actionDetectFilesystems_triggered);
    connect(ui->actionFsCheck, &QAction::triggered, this, &MainWindow::on_actionFsCheck_triggered);
    connect(ui->actionSearch, &QAction::triggered, this, &MainWindow::on_actionSearch_triggered);
    connect(ui->actionQuotaManager, &QAction::triggered, this, &MainWindow::on_actionQuotaManager_triggered);
    connect(ui->actionSnapshots, &QAction::triggered, this, &MainWindow::on_actionSnapshots_triggered);
    connect(ui->actionTreeView, &QAction::triggered, this, &MainWindow::on_actionTreeView_triggered);
    connect(ui->actionDetect_Filesystems, &QAction::triggered, this, &MainWindow::on_actionDetectFilesystems_triggered);
    
    // Fix for QMetaObject::connectSlotsByName warning - manually connect the actions with different names
    connect(ui->actionDetect_Filesystems, SIGNAL(triggered()), this, SLOT(on_actionDetectFilesystems_triggered()));
    
    // Initialize our modular components
    fsDetector = std::make_unique<FileSystemDetector>(this);
    treeViewManager = std::make_unique<TreeViewManager>(this, this);
    addDockWidget(Qt::LeftDockWidgetArea, treeViewManager->getDockWidget());
    connect(treeViewManager.get(), &TreeViewManager::directorySelected, this, &MainWindow::onDirectorySelected);
    
    // Initialize file operations and dialog handlers
    fileOps = std::make_unique<MainWindowFileOps>(this);
    dialogHandler = std::make_unique<MainWindowDialogs>(this);
    
    // Setup filesystem detection timer
    fsDetectionTimer = new QTimer(this);
    connect(fsDetectionTimer, &QTimer::timeout, this, &MainWindow::checkAvailableFilesystems);
    fsDetectionTimer->start(10000); // Check every 10 seconds
    
    // Initial filesystem detection
    checkAvailableFilesystems();
    
    // Set up toolbar
    setupFsToolbar();
    
    // Set window properties
    setWindowTitle("FileSystem Explorer");
    resize(900, 700);
}

MainWindow::~MainWindow()
{
    if (fs) {
        fs->unmount();
    }
    delete ui;
}

void MainWindow::setupMenus()
{
    // Already done in the UI file
}

void MainWindow::setupFsToolbar()
{
    ui->fsToolBar->setIconSize(QSize(24, 24));
    ui->fsToolBar->setToolButtonStyle(Qt::ToolButtonTextUnderIcon);
}

void MainWindow::refreshFileList()
{
    fileOps->refreshFileList();
}

void MainWindow::refreshTreeView()
{
    if (!fs || !treeViewManager) return;
    
    treeViewManager->refreshTreeView();
}

void MainWindow::on_formatButton_clicked()
{
    if (!fs) return;
    
    QMessageBox::StandardButton reply = QMessageBox::question(this, 
        "Format Confirmation", 
        "Are you sure you want to format the filesystem? All data will be lost.",
        QMessageBox::Yes | QMessageBox::No);
    
    if (reply == QMessageBox::Yes) {
        bool result = fs->format();
        if (result) {
            QMessageBox::information(this, "Format", "Filesystem formatted successfully.");
            
            // Reset UI
            ui->fileContentTextEdit->clear();
            ui->currentPathLabel->setText("/");
            refreshFileList();
        } else {
            QMessageBox::critical(this, "Error", "Failed to format filesystem.");
        }
    }
}

void MainWindow::on_mountButton_clicked()
{
    if (!fs) return;
    
    bool result = fs->mount();
    
    if (result) {
        QMessageBox::information(this, "Mount", "Filesystem mounted successfully.");
        
        // Enable UI elements
        ui->fileListWidget->setEnabled(true);
        ui->fileContentTextEdit->setEnabled(true);
        ui->saveButton->setEnabled(true);
        ui->mkdirButton->setEnabled(true);
        ui->createFileButton->setEnabled(true);
        ui->searchLineEdit->setEnabled(true);
        ui->searchButton->setEnabled(true);
        refreshFileList();
        
        // Initialize the utility classes
        fsck = std::make_unique<FileSystemCheck>(fs.get());
        search = std::make_unique<FileSystemSearch>(fs.get());
        quotaManager = std::make_unique<QuotaManager>(fs.get());
        snapshotManager = std::make_unique<SnapshotManager>(fs.get());
    }
    else
    {
        QMessageBox::critical(this, "Error", "Could not mount file system. Have you formatted it?");
    }
}

void MainWindow::on_fileListWidget_itemDoubleClicked(QListWidgetItem *item)
{
    fileOps->fileDoubleClicked(item);
}

void MainWindow::on_saveButton_clicked()
{
    fileOps->saveFile();
}

void MainWindow::on_mkdirButton_clicked()
{
    fileOps->createDirectory();
}

void MainWindow::on_createFileButton_clicked()
{
    fileOps->createFile();
}

void MainWindow::on_fileListWidget_customContextMenuRequested(const QPoint &pos)
{
    fileOps->fileContextMenu(pos);
}

void MainWindow::on_actionFsCheck_triggered()
{
    dialogHandler->handleFsCheck();
}

void MainWindow::on_actionSearch_triggered()
{
    dialogHandler->handleAdvancedSearch();
}

void MainWindow::on_searchButton_clicked()
{
    dialogHandler->handleQuickSearch();
}

void MainWindow::on_actionQuotaManager_triggered()
{
    dialogHandler->handleQuotaManager();
}

void MainWindow::on_actionSnapshots_triggered()
{
    dialogHandler->handleSnapshots();
}

void MainWindow::on_actionTreeView_triggered()
{
    if (treeViewManager) {
        bool isVisible = treeViewManager->getDockWidget()->isVisible();
        treeViewManager->getDockWidget()->setVisible(!isVisible);
    }
}

void MainWindow::on_actionDetectFilesystems_triggered()
{
    dialogHandler->handleFilesystemDetection();
}

void MainWindow::checkAvailableFilesystems()
{
    if (fsDetector) {
        fsDetector->detectFilesystems();
    }
}

void MainWindow::updateAvailableFilesystemsList()
{
    if (fsDetector) {
        availableFilesystems = fsDetector->getDetectedFilesystems();
    }
}

void MainWindow::onDirectorySelected(const std::string &path)
{
    if (!fs) return;
    
    current_open_file = "";
    ui->currentPathLabel->setText(QString::fromStdString(path));
    refreshFileList();
}

void MainWindow::dragEnterEvent(QDragEnterEvent *event)
{
    fileOps->handleDragEnterEvent(event);
}

void MainWindow::dropEvent(QDropEvent *event)
{
    fileOps->handleDropEvent(event);
}
